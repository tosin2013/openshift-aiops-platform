{{- if and .Values.notebooks .Values.notebooks.validation .Values.notebooks.validation.enabled }}
{{- /* Resolve git URL with fallback chain */ -}}
{{- $gitUrl := .Values.notebooks.validation.git.url | default .Values.git.repoURL | default .Values.global.git.repoURL | default "" }}
{{- $gitRef := .Values.notebooks.validation.git.ref | default .Values.git.revision | default .Values.global.git.revision | default "main" }}
---
# ImageStream for notebook-validator
# Stores the built image with all ML packages pre-installed
apiVersion: image.openshift.io/v1
kind: ImageStream
metadata:
  name: notebook-validator
  namespace: {{ .Values.main.namespace }}
  labels:
    app.kubernetes.io/name: notebook-validator
    app.kubernetes.io/component: notebook-validation
    app.kubernetes.io/part-of: self-healing-platform
  annotations:
    argocd.argoproj.io/sync-wave: "-5"
spec:
  lookupPolicy:
    local: true

{{- if $gitUrl }}
---
# BuildConfig for notebook-validator image
# Uses Docker strategy to build from RHOAI pytorch base image
# ArgoCD handles BuildConfigs natively (unlike PipelineRuns which are excluded)
apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: notebook-validator
  namespace: {{ .Values.main.namespace }}
  labels:
    app.kubernetes.io/name: notebook-validator
    app.kubernetes.io/component: notebook-validation
    app.kubernetes.io/part-of: self-healing-platform
  annotations:
    argocd.argoproj.io/sync-wave: "-4"
    description: |
      Builds the notebook-validator image with all ML packages pre-installed.
      Base: RHOAI pytorch:2025.1 (RHEL 9, enterprise supported)
      Adds: statsmodels, prophet, pyod, xgboost, lightgbm, seaborn, kserve
spec:
  source:
    type: Git
    git:
      uri: {{ $gitUrl }}
      ref: {{ $gitRef }}
    contextDir: notebooks
    sourceSecret:
      name: git-credentials
  strategy:
    type: Docker
    dockerStrategy:
      dockerfilePath: Dockerfile
      # Don't pull base image every time - use cached version if available
      forcePull: false
  output:
    to:
      kind: ImageStreamTag
      name: notebook-validator:latest
  resources:
    requests:
      cpu: "500m"
      memory: "2Gi"
    limits:
      cpu: "2"
      memory: "8Gi"
  # Build completion timeout (building pytorch base can take a while)
  completionDeadlineSeconds: 3600
  # Trigger on config change (first deployment)
  triggers:
    - type: ConfigChange

---
# Job to wait for notebook-validator image to be built
# This blocks ArgoCD sync until the image exists, ensuring dependent resources
# (NotebookValidationJobs, workbench) don't fail due to missing image
apiVersion: batch/v1
kind: Job
metadata:
  name: wait-for-notebook-validator-image
  namespace: {{ .Values.main.namespace }}
  labels:
    app.kubernetes.io/name: notebook-validator
    app.kubernetes.io/component: notebook-validation
    app.kubernetes.io/part-of: self-healing-platform
  annotations:
    argocd.argoproj.io/sync-wave: "-3"
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    description: "Waits for notebook-validator image build to complete"
spec:
  backoffLimit: 0
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        app.kubernetes.io/name: wait-for-notebook-validator-image
        app.kubernetes.io/component: notebook-validation
    spec:
      serviceAccountName: self-healing-operator
      restartPolicy: Never
      containers:
      - name: wait-for-image
        image: image-registry.openshift-image-registry.svc:5000/openshift/cli:latest
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "==========================================="
          echo "Waiting for notebook-validator image"
          echo "==========================================="

          NAMESPACE="{{ .Values.main.namespace }}"
          IMAGE_TAG="notebook-validator:latest"
          TIMEOUT=3600  # 1 hour timeout for build
          INTERVAL=30
          ELAPSED=0

          # Check if image already exists
          if oc get imagestreamtag "$IMAGE_TAG" -n "$NAMESPACE" &>/dev/null; then
            echo "✅ Image $IMAGE_TAG already exists"
            exit 0
          fi

          echo "Image not found, waiting for build to complete..."
          echo "Timeout: ${TIMEOUT}s"

          while [ $ELAPSED -lt $TIMEOUT ]; do
            # Check if image exists
            if oc get imagestreamtag "$IMAGE_TAG" -n "$NAMESPACE" &>/dev/null; then
              echo "✅ Image $IMAGE_TAG is now available!"
              exit 0
            fi

            # Check build status
            BUILD_STATUS=$(oc get builds -n "$NAMESPACE" -l buildconfig=notebook-validator --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].status.phase}' 2>/dev/null || echo "Unknown")

            case $BUILD_STATUS in
              Complete)
                echo "Build completed, verifying image..."
                sleep 5
                if oc get imagestreamtag "$IMAGE_TAG" -n "$NAMESPACE" &>/dev/null; then
                  echo "✅ Image $IMAGE_TAG is now available!"
                  exit 0
                fi
                ;;
              Failed|Error|Cancelled)
                echo "❌ Build failed with status: $BUILD_STATUS"
                oc get builds -n "$NAMESPACE" -l buildconfig=notebook-validator --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].status.message}' 2>/dev/null || true
                exit 1
                ;;
              Running|Pending|New|*)
                echo "Build status: $BUILD_STATUS (elapsed: ${ELAPSED}s/${TIMEOUT}s)"
                ;;
            esac

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "❌ Timeout waiting for image after ${TIMEOUT}s"
          exit 1
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "200m"
{{- end }}{{/* end if $gitUrl */}}

{{- end }}
