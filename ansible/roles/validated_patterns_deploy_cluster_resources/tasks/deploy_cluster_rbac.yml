---
# Deploy cluster-scoped RBAC resources (ClusterRole, ClusterRoleBinding)
# These are cluster-scoped resources that namespaced ArgoCD cannot manage
# Deployed via Ansible before ArgoCD syncs (Hybrid Management Model - ADR-030)

- name: Display cluster RBAC deployment message
  debug:
    msg: "Deploying cluster-scoped RBAC resources (ClusterRole, ClusterRoleBinding)"

# ==============================================================================
# Self-Healing Operator ClusterRole
# ==============================================================================

- name: Deploy Self-Healing Operator ClusterRole
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRole
      metadata:
        name: self-healing-operator-cluster
        labels:
          app.kubernetes.io/component: rbac
          app.kubernetes.io/name: self-healing-platform
          app.kubernetes.io/managed-by: ansible
      rules:
        # Cluster-scoped resources
        - apiGroups: [""]
          resources: ["namespaces", "nodes", "persistentvolumes"]
          verbs: ["get", "list", "watch"]
        # CRDs (cluster-scoped)
        - apiGroups: ["apiextensions.k8s.io"]
          resources: ["customresourcedefinitions"]
          verbs: ["get", "list", "watch"]
        # Storage classes
        - apiGroups: ["storage.k8s.io"]
          resources: ["storageclasses"]
          verbs: ["get", "list", "watch"]
  when: deploy_cluster_rbac | default(true) | bool

# ==============================================================================
# Self-Healing Workbench ClusterRole
# ==============================================================================

- name: Deploy Self-Healing Workbench ClusterRole
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRole
      metadata:
        name: self-healing-workbench-cluster
        labels:
          app.kubernetes.io/component: rbac
          app.kubernetes.io/name: self-healing-platform
          app.kubernetes.io/managed-by: ansible
      rules:
        # Cluster-scoped resources for data collection
        - apiGroups: [""]
          resources: ["namespaces", "nodes"]
          verbs: ["get", "list", "watch"]
        # Persistent volumes (cluster-scoped)
        - apiGroups: [""]
          resources: ["persistentvolumes"]
          verbs: ["get", "list", "watch"]
        # Storage classes (cluster-scoped)
        - apiGroups: ["storage.k8s.io"]
          resources: ["storageclasses"]
          verbs: ["get", "list", "watch"]
  when: deploy_cluster_rbac | default(true) | bool

- name: Deploy Self-Healing Workbench ClusterRoleBinding
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: self-healing-workbench-cluster
        labels:
          app.kubernetes.io/component: rbac
          app.kubernetes.io/name: self-healing-platform
          app.kubernetes.io/managed-by: ansible
      subjects:
        - kind: ServiceAccount
          name: self-healing-workbench
          namespace: "{{ pattern_namespace }}"
      roleRef:
        kind: ClusterRole
        name: self-healing-workbench-cluster
        apiGroup: rbac.authorization.k8s.io
  when: deploy_cluster_rbac | default(true) | bool

# ==============================================================================
# Prometheus Monitoring ClusterRoleBinding
# ==============================================================================

- name: Deploy Self-Healing Workbench Prometheus ClusterRoleBinding
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: self-healing-workbench-prometheus
        labels:
          app.kubernetes.io/component: rbac
          app.kubernetes.io/name: self-healing-platform
          app.kubernetes.io/managed-by: ansible
      subjects:
        - kind: ServiceAccount
          name: self-healing-workbench
          namespace: "{{ pattern_namespace }}"
      roleRef:
        kind: ClusterRole
        name: cluster-monitoring-view
        apiGroup: rbac.authorization.k8s.io
  when: deploy_cluster_rbac | default(true) | bool

# ==============================================================================
# External Secrets Operator RBAC (if ESO is deployed)
# ==============================================================================

- name: Deploy External Secrets ClusterRole
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRole
      metadata:
        name: "external-secrets-{{ pattern_namespace }}"
        labels:
          app.kubernetes.io/name: external-secrets
          app.kubernetes.io/component: rbac
          app.kubernetes.io/managed-by: ansible
      rules:
        - apiGroups: [""]
          resources: ["secrets"]  # pragma: allowlist secret
          verbs: ["get", "list", "watch"]
        - apiGroups: [""]
          resources: ["configmaps"]
          verbs: ["get", "list", "watch"]
  when:
    - deploy_cluster_rbac | default(true) | bool
    - deploy_eso_rbac | default(true) | bool

- name: Deploy External Secrets ClusterRoleBinding
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: "external-secrets-{{ pattern_namespace }}"
        labels:
          app.kubernetes.io/name: external-secrets
          app.kubernetes.io/component: rbac
          app.kubernetes.io/managed-by: ansible
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: "external-secrets-{{ pattern_namespace }}"
      subjects:
        - kind: ServiceAccount
          name: "{{ eso_service_account | default('external-secrets') }}"
          namespace: "{{ pattern_namespace }}"
  when:
    - deploy_cluster_rbac | default(true) | bool
    - deploy_eso_rbac | default(true) | bool

# ==============================================================================
# Hub-GitOps ArgoCD Application Controller RBAC (Namespaced Mode Support)
# ==============================================================================
# Grant cluster-admin to hub-gitops ArgoCD application controller
# This is required because the hub-gitops instance runs in namespaced mode
# but needs to manage cluster-scoped resources (ClusterRole, ClusterRoleBinding)
# See ADR-030: Hybrid Management Model for Namespaced ArgoCD Deployments
# This fixes the error: "ClusterRoleBinding cannot be managed when in namespaced mode"

- name: Deploy hub-gitops ArgoCD Application Controller ClusterRoleBinding
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: hub-gitops-argocd-application-controller-cluster-admin
        labels:
          app.kubernetes.io/component: application-controller
          app.kubernetes.io/instance: hub-gitops
          app.kubernetes.io/name: argocd-application-controller
          app.kubernetes.io/part-of: argocd
          app.kubernetes.io/managed-by: ansible
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: cluster-admin
      subjects:
      - kind: ServiceAccount
        name: hub-gitops-argocd-application-controller
        namespace: "{{ pattern_namespace }}-hub"
  when: deploy_cluster_rbac | default(true) | bool

# ==============================================================================
# MCP Server ClusterRole
# ==============================================================================

- name: Deploy MCP Server ClusterRole
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRole
      metadata:
        name: self-healing-platform-mcp-server-cluster
        labels:
          app.kubernetes.io/component: mcp-server
          app.kubernetes.io/name: self-healing-platform
          app.kubernetes.io/managed-by: ansible
      rules:
        # Core Kubernetes resources (read-only)
        - apiGroups: [""]
          resources: [nodes, pods, events, namespaces, persistentvolumes, services, configmaps]
          verbs: [get, list, watch]
        # Apps resources (read-only)
        - apiGroups: ["apps"]
          resources: [deployments, statefulsets, daemonsets, replicasets]
          verbs: [get, list, watch]
        # Batch resources (read-only)
        - apiGroups: ["batch"]
          resources: [jobs, cronjobs]
          verbs: [get, list, watch]
        # Storage resources (read-only)
        - apiGroups: ["storage.k8s.io"]
          resources: [storageclasses, volumeattachments]
          verbs: [get, list, watch]
        # Custom Resource Definitions (read-only)
        - apiGroups: ["apiextensions.k8s.io"]
          resources: [customresourcedefinitions]
          verbs: [get, list, watch]
        # OpenShift-specific resources (read-only)
        - apiGroups: ["route.openshift.io"]
          resources: [routes]
          verbs: [get, list, watch]
        # Monitoring resources (read-only)
        - apiGroups: ["monitoring.coreos.com"]
          resources: [servicemonitors, prometheusrules]
          verbs: [get, list, watch]
        # KServe InferenceServices (read-only)
        - apiGroups: ["serving.kserve.io"]
          resources: [inferenceservices]
          verbs: [get, list, watch]
        # Knative Serving (read-only)
        - apiGroups: ["serving.knative.dev"]
          resources: [services, routes, configurations, revisions]
          verbs: [get, list, watch]
  when: deploy_cluster_rbac | default(true) | bool

- name: Deploy MCP Server ClusterRoleBinding
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: self-healing-platform-mcp-server-cluster
        labels:
          app.kubernetes.io/component: mcp-server
          app.kubernetes.io/name: self-healing-platform
          app.kubernetes.io/managed-by: ansible
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: self-healing-platform-mcp-server-cluster
      subjects:
        - kind: ServiceAccount
          name: self-healing-operator
          namespace: "{{ pattern_namespace }}"
  when: deploy_cluster_rbac | default(true) | bool

- name: Deploy MCP Prometheus ClusterRoleBinding
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: self-healing-platform-mcp-prometheus
        labels:
          app.kubernetes.io/component: mcp-server
          app.kubernetes.io/name: self-healing-platform
          app.kubernetes.io/managed-by: ansible
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: cluster-monitoring-view
      subjects:
        - kind: ServiceAccount
          name: self-healing-operator
          namespace: "{{ pattern_namespace }}"
  when: deploy_cluster_rbac | default(true) | bool

# ==============================================================================
# Jupyter Notebook Validator Operator ClusterRole
# ==============================================================================

- name: Deploy Jupyter Notebook Validator Operator ClusterRole
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRole
      metadata:
        name: jupyter-notebook-validator-operator
        labels:
          app.kubernetes.io/name: jupyter-notebook-validator
          app.kubernetes.io/component: rbac
          app.kubernetes.io/managed-by: ansible
      rules:
        - apiGroups: [""]
          resources: ["pods", "pods/log", "pods/exec", "serviceaccounts"]
          verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
        - apiGroups: [""]
          resources: ["secrets", "configmaps"]  # pragma: allowlist secret
          verbs: ["get", "list", "watch"]
        - apiGroups: ["batch"]
          resources: ["jobs"]
          verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
        - apiGroups: ["mlops.mlops.dev"]
          resources: ["notebookvalidationjobs", "notebookvalidationjobs/status", "notebookvalidationjobs/finalizers"]
          verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
        - apiGroups: [""]
          resources: ["events"]
          verbs: ["create", "patch"]
  when: deploy_cluster_rbac | default(true) | bool

- name: Deploy Jupyter Notebook Validator Operator ClusterRoleBinding
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: jupyter-notebook-validator-operator
        labels:
          app.kubernetes.io/name: jupyter-notebook-validator
          app.kubernetes.io/component: rbac
          app.kubernetes.io/managed-by: ansible
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: jupyter-notebook-validator-operator
      subjects:
        - kind: ServiceAccount
          name: jupyter-notebook-validator-operator
          namespace: jupyter-notebook-validator-system
  when: deploy_cluster_rbac | default(true) | bool

- name: Display cluster RBAC deployment status  # pragma: allowlist secret
  debug:
    msg: |
      âœ… Cluster-scoped RBAC resources deployed:
      - ClusterRole: self-healing-operator-cluster
      - ClusterRole: self-healing-workbench-cluster
      - ClusterRoleBinding: self-healing-workbench-cluster
      - ClusterRoleBinding: self-healing-workbench-prometheus
      - ClusterRole: external-secrets-{{ pattern_namespace }} (if ESO enabled)  # pragma: allowlist secret
      - ClusterRoleBinding: external-secrets-{{ pattern_namespace }} (if ESO enabled)  # pragma: allowlist secret
      - ClusterRoleBinding: hub-gitops-argocd-application-controller-cluster-admin
      - ClusterRole: self-healing-platform-mcp-server-cluster
      - ClusterRoleBinding: self-healing-platform-mcp-server-cluster
      - ClusterRoleBinding: self-healing-platform-mcp-prometheus
      - ClusterRole: jupyter-notebook-validator-operator
      - ClusterRoleBinding: jupyter-notebook-validator-operator

      These allow:
      - Operator: Access to cluster-scoped resources (namespaces, nodes, CRDs)
      - Workbench: Access to cluster-scoped resources for monitoring
      - Workbench: Access to Prometheus metrics via cluster-monitoring-view role
      - External Secrets: Access to secrets and configmaps cluster-wide  # pragma: allowlist secret
      - Hub-GitOps ArgoCD: Manage cluster-scoped resources from namespaced mode (ADR-030)
      - MCP Server: Read-only cluster-wide access for monitoring and diagnostics
      - MCP Server: Prometheus metrics access
      - Jupyter Notebook Validator: Manage NotebookValidationJob CRs and pods
